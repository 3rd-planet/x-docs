{"/":{"title":"Welcome to Framework X","data":{"":"Your Accelerated Path to API Creation","what-is-framework-x#What is Framework X?":"In the dynamic realm of web development, efficiency and structure are paramount. Enter Framework X, a game-changing solution designed to revolutionize the process of crafting APIs. With a focus on speed and simplicity, Framework X is the perfect tool for developers of all skill levels.Framework X emerges as a beacon for developers seeking to streamline their API creation journey. Crafted with ingenuity, it offers an ingenious approach to expediting development while upholding a rigid architectural foundation.The framework's core strength lies in its seamless integration with Sequelize, a powerful Object-Relational Mapping (ORM) tool. This integration empowers developers to effortlessly define models, establish relationships, and interact with their database, all while adhering to the coveted model and controller paradigm.Though, Framework X's utility extends far beyond its integration with Sequelize. The framework also offers a robust routing system, allowing developers to easily define their API endpoints And with the help of the framework's built-in middleware, developers can easily implement authentication, logging, and more.What truly sets Framework X apart is its meticulously structured architecture. It provides developers with a clear and standardized layout for models, controllers, and routes, eliminating the hassle of conceptualizing the organization from scratch. This rigid structure not only saves time but also cultivates a consistent and maintainable codebase.In this fast-paced digital landscape, Framework X stands as a testament to innovation and practicality. Whether you're a seasoned developer or just embarking on your coding journey, Framework X equips you with the tools to propel your API development to unprecedented heights. Say goodbye to ambiguity and welcome the dawn of swift, structured, and successful API creation with Framework X.","vision#Vision":"The vision of Framework X is to provide developers with a simple, yet powerful, tool to create APIs. The framework is designed to be easy to use, while still providing the flexibility to create complex APIs. The framework is also designed to be extensible, allowing developers to easily add new features and functionality.","motivation#Motivation":"The motivation behind Framework X is the pain every developer goes through ones in their life. The pain of creating a new API setup from scratch. In the era of microservices, APIs are the backbone of every application and the framework is designed to make the process of creating APIs easier and faster to strengthen that backbone."}},"/contributors":{"title":"Contributors","data":{"":"Framework X relies on a collaborative community of developers and enthusiasts who actively contribute to its development, improvement, and maintenance. This collective effort fosters innovation, ensures continuous updates, and creates a robust ecosystem around the framework, making it a dynamic and thriving platform for various applications and solutions.","core-team#Core Team":"The core team is responsible for the overall development and maintenance of the framework. It is composed of the following members:\n@msamgan\n@hudaQeshta","want-to-help#Want to help?":"We welcome contributions from the community. Please review the Contribution Guidelines for more information."}},"/overview/repositories":{"title":"Repositories","data":{"repository-pattern#Repository pattern":"The Repository Pattern is a design pattern commonly used in software development to separate the logic that retrieves data from a data store (such as a database) from the rest of the application's code. It provides a way to abstract and encapsulate the data access layer, making it easier to manage and maintain the codebase, improve testability, and promote a more structured and modular architecture.","goal-of-repository-pattern#Goal of repository pattern":"The goal of the repository pattern is to abstract and centralize data access logic in software applications. By providing a consistent interface for accessing data, it promotes separation of concerns, making it easier to manage and maintain code. This pattern enhances testability, scalability, and flexibility by decoupling the application's business logic from the underlying data storage mechanisms, allowing developers to switch between different data sources (e.g., databases, APIs) without affecting the core application logic.","benefit-of-repository-pattern#Benefit of repository pattern":"Separation of Concerns: It separates the data access logic from the business logic, promoting a clean and maintainable codebase.\nTestability: It simplifies unit testing because you can easily mock or substitute the repository with fake implementations for testing purposes.\nFlexibility: It allows you to switch between different data storage technologies or even replace the entire data access layer without affecting the application's core logic.\nCentralized Data Access: It provides a centralized location for managing data access concerns, making it easier to implement caching, logging, and other cross-cutting concerns.\nOverall, the Repository Pattern is a valuable tool for designing software applications that need to interact with data stores while maintaining a high level of flexibility, maintainability, and testability.","create-repository#Create repository":"You can create a repository by using the following CLI command:\nnode x build:repository <repository-name>","example#Example":"node x build:repository user\nand this will create a file in repositories/user.repository.js"}},"/overview/opinionated-project-template":{"title":"Opinionated Project Template","data":{"":"Framework X is a meticulously designed solution to kickstart your project. With predefined best practices and structures. Embrace our expert recommendations or customize. Either way, you're set up for success, saving time and ensuring quality from the get-go\n/\n├── controllers\n│   └── index.controller.js\n├── helpers\n│   └── methods.js\n├── http\n│   └── index.http\n├── index.js\n├── log\n│   ├── access\n│   └── error\n├── middlewares\n│   ├── error.middleware.js\n│   ├── logger.middleware.js\n│   └── validators\n│       └── index.validations.js\n├── package-lock.json\n├── package.json\n├── routes\n│   └── api.js\n├── server.js\n├── tests\n│   ├── index.fail.validation.test.js\n│   ├── index.get.test.js\n│   └── index.post.test.js\n└── x\nFile/Directory Name\tDescription\tcontrollers\tThe controller directory. it contains all the controller files. Nested directories are also supported.\thelpers\tAny sort of helpers required by the project are contained in this directory. By default, it comes with methods.js with some handy methods.\thttp\tThis directory contains the .http files. You can find more details about .http files here\tlog\tStores access and error logs by date.\tmiddlewares\tThis directory contains all the middleware. Framework X comes with some default middleware which we will discuss in detail in further documentation.\tmiddlewares.validators\tThis directory contains request validators. Framework X uses express-validator under the hood.\troutes\tThis directory contains all the API routes. You can find more details about Express Routes here.\ttests\tThis is the \"tests\" directory\tindex.js\tCreates the Application instance with ExpressJS\tserver.js\tCreated Server from the app instance provided by index.js. \"server.js\" is the entry point for Framework X\tx\tCLI access point.","helpersmethodsjs#helpers/methods.js":"This file contains some handy methods that can be used throughout the project. It is a good practice to keep all the helper methods in this file. You can add more methods as per your project requirements.","successresponse#successResponse":"This method is used to send a success response to the client.\n/**\n *\n * @param message\n * @param payload\n * @param statusCode\n * @returns {\n *     {\n *     message: *,\n *     status: boolean,\n *     status_code: number,\n *     package: *\n *     }\n * }\n * @example\n *  const { successResponse } = require(\"../helpers/methods\")\n *  res.status(200).json(successResponse(\"User created successfully\", user, 200))\n */\nexports.successResponse = (message, payload, statusCode = 200) => {\n    return {\n        status: true,\n        status_code: statusCode,\n        message: message,\n        package: payload\n    }\n}","failresponse#failResponse":"This method is used to send an error response to the client.\n/**\n *\n * @param message\n * @param payload\n * @param statusCode\n * @returns {\n *     {\n *     message: *,\n *     status: boolean,\n *     status_code: number,\n *     package: *\n *     }\n * }\n * @example\n *  const { failResponse } = require(\"../helpers/methods\")\n *  res.status(400).json(failResponse(\"Validation failed\", errors.array(), 400))\n *\n * */\nexports.failResponse = (message, payload = null, statusCode = 400) => {\n    let response = {\n        status: false,\n        status_code: statusCode,\n        message: message\n    }\n    if (payload) {\n        response.payload = payload\n    }\n    return response\n}","validate#validate":"This method is used to validate the request. It uses express-validator under the hood.\n/**\n * sequential processing, stops running validations chain if the previous one have failed.\n * @param validations\n * @returns {function(*=, *=, *): Promise<*>}\n * @example\n *  const { validate } = require(\"../helpers/methods\")\n *  const { indexValidator } = require(\"../middlewares/validators/index.validations\")\n *  router.post(\"/\", validate(indexValidator), IndexController.indexPost)\n */\nexports.validate = (validations) => {\n    return async (req, res, next) => {\n        for (let validation of validations) {\n            const result = await validation.run(req)\n            if (result.errors.length) break\n        }\n        const errors = validationResult(req)\n        if (errors.isEmpty()) {\n            return next()\n        }\n        res.status(parseInt(process.env.VALIDATION_FAIL_CODE)).json(\n            this.failResponse(\"Validation failed\", errors.array())\n        )\n    }\n}","middlewares#middlewares":"This directory contains all the middleware. Framework X comes with 2 default middleware menthioned below.\nlogger.middleware.js\nerror.middleware.js","loggermiddlewarejs#logger.middleware.js":"This middleware is used to log all the requests and responses. It uses simple-node-logger under the hood.\nconst accessLog = require(\"simple-node-logger\").createSimpleLogger({\n    logFilePath: \"./log/access/\" + new Date().toLocaleDateString().split(\"/\").join(\"-\") + \".log\",\n    timestampFormat: \"YYYY-MM-DD HH:mm:ss\"\n})\n/**\n *\n * @param req\n * @param res\n * @param next\n * @returns {*}\n */\nmodule.exports = (req, res, next) => {\n    let reqObject = {\n        method: req.method,\n        path: req.path,\n        param: req.params,\n        body: req.body\n    }\n    let resObject = {\n        statusCode: res.statusCode\n    }\n    accessLog.info(\n        JSON.stringify({\n            reqObject,\n            resObject\n        })\n    )\n    next()\n}","errormiddlewarejs#error.middleware.js":"This middleware is used to handle all the errors. It uses simple-node-logger under the hood. Also, Framework X use express-async-errors to handle async errors. Any exception thrown will be handled by this middleware and a fail response will be sent to the client.\nconst methods = require(\"../helpers/methods\")\nconst errorLog = require(\"simple-node-logger\").createSimpleLogger({\n    logFilePath: \"./log/error/\" + new Date().toLocaleDateString().split(\"/\").join(\"-\") + \".log\",\n    timestampFormat: \"YYYY-MM-DD HH:mm:ss\"\n})\n/**\n *\n * @param error\n * @param req\n * @param res\n * @param next\n * @returns {*}\n */\n// eslint-disable-next-line no-unused-vars\nmodule.exports = (error, req, res, next) => {\n    errorLog.error(error.message)\n    return res.status(process.env.EXCEPTION_CODE).send(methods.failResponse(error.message))\n}","middlewaresvalidators#middlewares/validators":"This directory contains request validators. Framework X uses express-validator under the hood.","indexjs#index.js":"This file creates the Application instance with ExpressJS. It also loads all the middlewares, routes and everything else required to run the application. index.js exports the app instance which is used by server.js to create the server.\nrequire(\"dotenv\").config()\nrequire(\"express-async-errors\")\nconst accessLogMiddleware = require(\"./middlewares/logger.middleware\")\nconst routes = require(\"./routes/api\")\nconst express = require(\"express\")\nconst app = express()\nconst cors = require(\"cors\")\napp.use(cors())\napp.use(express.json())\n// Req and Res logger.\napp.use(accessLogMiddleware)\napp.use(\"/\", routes)\nmodule.exports = app","serverjs#server.js":"This file creates the server from the app instance provided by index.js. \"server.js\" is the entry point for Framework X.\nconst app = require(\"./index\")\nconst port = process.env.PORT\nconst errorMiddleware = require(\"./middlewares/error.middleware\")\nconsole.log(`Node environment: ${process.env.NODE_ENV}`)\napp.listen(port, () => {\n    console.log(`Example app listening at port http://localhost:${port}`)\n})\n// Error Handler Middleware\napp.use(errorMiddleware)","x#x":"This is the CLI access point. It is used to control the CLI utilities of Framework X. You can find more details about CLI here"}}}